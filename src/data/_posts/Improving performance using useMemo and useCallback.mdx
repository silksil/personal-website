---
title: 'Improving performance using useMemo and useCallback'
createdAt: '2022-04-16'
description: 'Hello world how are you doing I like this.Hello world how are you doing I like this.Hello world how are you doing I like this.Hello world how are you doing I like this.Hello world how are you doing I like this.Hello world how are you doing I like this.Hello world how are you doing I like this.Hello world how are you doing I like this.'
cover_image: 'https://res.cloudinary.com/kentcdodds-com/image/upload/w_2100,q_auto,f_auto,b_rgb:e6e9ee/unsplash/photo-1453728013993-6d66e9c9123a'
---

In the precious email spalined when a component re-renders and how this can impact performance. useMemo and useCallback are two build in React hooks that help you deal with this using memoization.

Memoization is a technique that helps you “remember” expensive functions in order to avoid calling them on every render. Think of it as caching a value so that it does not need to be recalculated.

For example, if we have a function compute `1 x 2`, it will return `2`. But if it uses memoization, the next time we run the the function, it will not execute function again. Instead, it will remember that the answer is `2`  without executing the function.

# useMemo()

useMemo is a hook that allows you using memoization by wrapping a function with the hook. It does this by accepting 2 arguments: a function that `computes` a result, and the `depedencies` array.

```jsx
const memoizedResult = useMemo(() => compute, depencies).
```

During initial rendering, useMemo invokes `compute`, memoizes the calculation result, and returns it.

If during next renderings the dependencies don't change, then `useMemo()` *doesn't invoke* `compute` , but instead returns the memoized value.

But if dependencies change during re-rendering, then `useMemo()` *invoke*`compute` again, memoizes the new value, and returns it. If your dependencies array is not provided, there is no possibility of memoization, and it will invoke compute on every render.

# useMemo() - Example

A component `<App />` does three main things:

- Keeps the amount of times a user has clicked on a button
- Does a calculation based on the count.
- Allows a user type into an input field.

```jsx
import React, { useState, useMemo } from "react";

const expensiveCalculation = (num) => {
  for (let i = 0; i < 1000000000; i++) {
    num += 1;
  }
  return num;
};

const App = () => {
  const [count, setCount] = useState(0);
  const [namem, setName] useState("")
  const calculation = expensiveCalculation(count);
  const onChange = event => {
    setName(event.target.value);
  };

  return (
    <>
      <h1> Type here to show how useMemo works </h1>
      <input value={name} onChange={onChange} />
      <button onClick={increment}>+</button>
      <h2>Expensive Calculation</h2>
      <p>{calculation}</p>
    </>
  );
};

export default App;
```

When changing the count or typing in the input field, there will be a delay in execution due to the function `expensiveCalculation` that is being run during every state change. This can be fixed by using `useMemo` to memoize this function.

In the following example, the expensive function will only run when `count` is changed, and not when the input value changes. The reason why expensive function is being run when the count changes, is because `expensiveCalculations` has a dependency on it.

```jsx
import React, { useState, useMemo } from "react";

const expensiveCalculation = (num) => {
  for (let i = 0; i < 1000000000; i++) {
    num += 1;
  }
  return num;
};

const App = () => {
  const [count, setCount] = useState(0);
	const [namem, setName] useState("")
  const calculation = useMemo(() => expensiveCalculation(count), [count]);

	const onChange = event => {
		    setName(event.target.value);
	};

  return (
    <>
			<h1> Type here to show how useMemo works </h1>
			<input value={name} onChange={onChange} />
      <button onClick={increment}>+</button>
			<h2>Expensive Calculation</h2>
			<p>{calculation}</p>
    </t>
  );
};

export default App;
```

## useCallback()

The useCallback hook is similar to useMemo, but it returns a **memoized callback** rather than **memoized value**.

> `useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)`. — React Documentation

Instead of using useMemo, we could also `useCallback` to prevent re-rendering when typing in the input field.

```jsx
import React, { useState, useMemo } from "react";

const expensiveCalculation = (num) => {
  console.log("Calculating...");
  for (let i = 0; i < 1000000000; i++) {
    num += 1;
  }
~~~~  return num;
};

const App = () => {
  const [count, setCount] = useState(0);
	const [namem, setName] useState("")
  const calculation = useCallback(expensiveCalculation(count), [count]);

	const onChange = event => {
		    setName(event.target.value);
	};
  return (
    <>
			<h1> Type here to show how useMemo works </h1>
			<input value={name} onChange={onChange} />
      <button onClick={increment}>+</button>
			<h2>Expensive Calculation</h2>
			<p>{calculation}</p>
    </t>
  );
};

	export default App;
```

## When to use useMemo and useCallback?

- To prevent computationally expensive calculations
- To deal with referential equality

### **To prevent computationally expensive calculations**

We should use useMemo and useCallback whenever we make “expensive” calculations. But what is expensive? Re-rendering components of which the UI isn’t impacted by state changes is often not a bad thing, as components are often small and cheap.

In fact, including `useMemo` and `useCallback` can actually decrease performance, as **very line of code which is executed comes with a cost. E**ven if it would improve the performance, but the saving would be very minimal, the cost of making the code more complex is probably not worth it.

> **Performance optimizations are not free. They ALWAYS come with a cost but do NOT always come with a benefit to offset that cost. —Kent C. Dodds**

### To deal with referential equality

When React checks for any changes in a component, it may detect an unintended or unexpected change due to how JavaScript handles equality and shallow comparisons. This change in the React application will cause it to re-render unnecessarily. We will cover this more extensively in the next email.

### To refer to the same object

TODO: explain referential equality.

[https://dmitripavlutin.com/react-usememo-hook/](https://dmitripavlutin.com/react-usememo-hook/)

[https://www.digitalocean.com/community/tutorials/react-usememo](https://www.digitalocean.com/community/tutorials/react-usememo)

[https://procoders.tech/blog/difference-between-usememo-and-usecallback/](https://procoders.tech/blog/difference-between-usememo-and-usecallback/)
